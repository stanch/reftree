"use strict";(self.webpackChunkreftree=self.webpackChunkreftree||[]).push([[814],{6444:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>h});var s=a(4848),r=a(8453),t=a(3554),i=a.n(t);const l={sidebar_position:1,description:"This talk takes advantage of reftree to observe several immutable data structures in action and uncover their inner beauty. Having surfaced immutability\u2019s crucial tricks, we move our focus to lenses and zippers \u2014 handy tools that combine the convenience of the \u201cmutable world\u201d with the expressiveness of functional programming."},c="Unzipping Immutability",o={id:"talks/Immutability",title:"Unzipping Immutability",description:"This talk takes advantage of reftree to observe several immutable data structures in action and uncover their inner beauty. Having surfaced immutability\u2019s crucial tricks, we move our focus to lenses and zippers \u2014 handy tools that combine the convenience of the \u201cmutable world\u201d with the expressiveness of functional programming.",source:"@site/../site-gen/target/mdoc/talks/Immutability.md",sourceDirName:"talks",slug:"/talks/Immutability",permalink:"/reftree/docs/talks/Immutability",draft:!1,unlisted:!1,editUrl:"https://github.com/stanch/reftree/tree/main/docs/../site-gen/target/mdoc/talks/Immutability.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"This talk takes advantage of reftree to observe several immutable data structures in action and uncover their inner beauty. Having surfaced immutability\u2019s crucial tricks, we move our focus to lenses and zippers \u2014 handy tools that combine the convenience of the \u201cmutable world\u201d with the expressiveness of functional programming."},sidebar:"mainSidebar",previous:{title:"Talks / Demos",permalink:"/reftree/docs/talks/"},next:{title:"Visualize your data structures!",permalink:"/reftree/docs/talks/Visualize"}},d={},h=[{value:"Immutable data structures",id:"immutable-data-structures",level:2},{value:"Lists",id:"lists",level:3},{value:"Queues",id:"queues",level:3},{value:"Vectors",id:"vectors",level:3},{value:"Finger Trees",id:"finger-trees",level:3},{value:"Lenses",id:"lenses",level:2},{value:"Zippers",id:"zippers",level:2},{value:"Useful resources",id:"useful-resources",level:2},{value:"Books, papers and talks",id:"books-papers-and-talks",level:3},{value:"Scala libraries",id:"scala-libraries",level:3}];function p(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"unzipping-immutability",children:"Unzipping Immutability"}),"\n",(0,s.jsx)(n.p,{children:"This page contains the materials for my talk \u201cUnzipping Immutability\u201d."}),"\n","\n",(0,s.jsx)(i(),{controls:!0,style:{marginBottom:"1em"},url:"https://www.youtube.com/watch?v=dOj-wk5MQ3k"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Older videos"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["LX Scala, April 2016: ",(0,s.jsx)(n.a,{href:"https://vimeo.com/162214356",children:"https://vimeo.com/162214356"})]}),"\n",(0,s.jsxs)(n.li,{children:["Pixels Camp, October 2016: ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=yeMvhuD689A",children:"https://www.youtube.com/watch?v=yeMvhuD689A"})]}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"You can use this page in two ways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"as a reference/refresher on the concepts covered in the talk;"}),"\n",(0,s.jsx)(n.li,{children:"as an interactive playground where you can try the same commands I presented."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Throughout this page we will assume the following\ndeclarations (each section might add its own):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import reftree.core._\nimport reftree.diagram._\nimport reftree.render._\nimport reftree.demo.Data._\nimport scala.collection.immutable._\nimport java.nio.file.Paths\nimport Diagram.{sourceCodeCaption => diagram}\n"})}),"\n",(0,s.jsx)(n.p,{children:"To start an interactive session, just run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ sbt demo\n@ render(List(1, 2, 3))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and open ",(0,s.jsx)(n.code,{children:"diagram.png"})," in your favorite image viewer (hopefully one that\nreloads images automatically on file change). You will also need to have\n",(0,s.jsx)(n.a,{href:"http://www.graphviz.org/",children:"GraphViz"})," installed. ",(0,s.jsx)(n.em,{children:"The interactive session\nalready has all the necessary imports in scope."})]}),"\n",(0,s.jsx)(n.h2,{id:"immutable-data-structures",children:"Immutable data structures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'// extra declarations for this section\nval renderer = Renderer(\n  renderingOptions = RenderingOptions(density = 100),\n  directory = Paths.get(ImagePath, "immutability")\n)\nimport renderer._\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lists",children:"Lists"}),"\n",(0,s.jsx)(n.p,{children:"We\u2019ll start with one of the simplest structures: a list.\nIt consists of a number of cells pointing to each other:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val list = List(1, 2, 3)\n// list: List[Int] = List(1, 2, 3)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(list).render("list")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"list",src:a(8603).A+"",width:"322",height:"590"})}),"\n",(0,s.jsx)(n.p,{children:"Elements can be added to or removed from the front of the list with no effort,\nbecause we can share the same cells across several lists.\nThis would not be possible with a mutable list,\nsince modifying the shared part would modify every data structure making use of it."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val add = 0 :: list\n// add: List[Int] = List(0, 1, 2, 3)\nval remove = list.tail\n// remove: List[Int] = List(2, 3)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(list) + diagram(add) + diagram(remove)).render("lists")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"lists",src:a(2600).A+"",width:"455",height:"722"})}),"\n",(0,s.jsxs)(n.p,{children:["However we can\u2019t easily add elements at the end of the list, since the last cell\nis pointing to the empty list (",(0,s.jsx)(n.code,{children:"Nil"}),") and is immutable, i.e. cannot be changed.\nThus we are forced to create a new list every time:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(Animation\n  .startWith(List(1))\n  .iterate(_ :+ 2, _ :+ 3, _ :+ 4)\n  .build()\n  .render("list-append", tweakAnimation = _.withOnionSkinLayers(3)))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"list-append",src:a(2773).A+"",width:"675",height:"722"})}),"\n",(0,s.jsx)(n.p,{children:"This certainly does not look efficient compared to adding elements at the front:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(Animation\n  .startWith(List(1))\n  .iterate(2 :: _, 3 :: _, 4 :: _)\n  .build()\n  .render("list-prepend"))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"list-prepend",src:a(2515).A+"",width:"457",height:"722"})}),"\n",(0,s.jsx)(n.h3,{id:"queues",children:"Queues"}),"\n",(0,s.jsx)(n.p,{children:"If we want to add elements on both sides efficiently, we need a different data structure: a queue.\nThe queue below, also known as a \u201cBanker\u2019s Queue\u201d, has two lists: one for prepending and one for appending."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val queue1 = Queue(1, 2, 3)\n// queue1: Queue[Int] = Queue(1, 2, 3)\nval queue2 = (queue1 :+ 4).tail\n// queue2: Queue[Int] = Queue(2, 3, 4)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(queue1) + diagram(queue2)).render("queues", _.withVerticalSpacing(1.2))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"queues",src:a(5623).A+"",width:"607",height:"992"})}),"\n",(0,s.jsx)(n.p,{children:"This way we can add and remove elements very easily at both ends.\nExcept when we try to remove an element and the respective list is empty!\nIn this case the queue will rotate the other list to make use of its elements.\nAlthough this operation is expensive, the usage pattern intended for a queue\nmakes it rare enough to yield great average (\u201cammortized\u201d) performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(Animation\n  .startWith(Queue(1, 2, 3))\n  .repeat(3)(_.iterate(2)(q => q :+ (q.max + 1)).iterate(2)(_.tail))\n  .build(Diagram.toStringCaption(_).withAnchor("queue"))\n  .render("queue"))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"queue",src:a(9696).A+"",width:"540",height:"922"})}),"\n",(0,s.jsx)(n.h3,{id:"vectors",children:"Vectors"}),"\n",(0,s.jsxs)(n.p,{children:["One downside common to both lists and queues we saw before is that to get an element by index,\nwe need to potentially traverse the whole structure. A ",(0,s.jsx)(n.code,{children:"Vector"})," is a powerful data structure\naddressing this shortcoming and available in Scala (among other languages, like Clojure)."]}),"\n",(0,s.jsx)(n.p,{children:"Internally vectors utilize up to 6 layers of arrays, where 32 elements sit on the first layer,\n1024 \u2014 on the second, 32^3 \u2014 on the third, etc.\nTherefore getting any element by its index requires at most 6 pointer dereferences,\nwhich can be deemed constant time (yes, the trick is that the number of elements that can\nbe stored is limited by 2^31)."}),"\n",(0,s.jsx)(n.p,{children:"The internal 32-element arrays form the basic structural sharing blocks.\nFor small vectors they will be recreated on most operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val vector1 = (1 to 20).toVector\n// vector1: Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)\nval vector2 = vector1 :+ 21\n// vector2: Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(vector1) + diagram(vector2)).render("vectors", _.withVerticalSpacing(2))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"vectors",src:a(1999).A+"",width:"2022",height:"601"})}),"\n",(0,s.jsx)(n.p,{children:"However as more layers leap into action, a huge chunk of the data can be shared:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val vector3 = (1 to 100).toVector\n// vector3: Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100)\nval vector4 = vector3 :+ 21\n// vector4: Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 21)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(vector3) + diagram(vector4)).render("big-vectors", _.withVerticalSpacing(2))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"big-vectors",src:a(5390).A+"",width:"3785",height:"853"})}),"\n",(0,s.jsxs)(n.p,{children:["If you want to know more, this structure is covered in great detail by Jean Niklas L\u2019orange\n",(0,s.jsx)(n.a,{href:"http://hypirion.com/musings/understanding-persistent-vector-pt-1",children:"in his blog"}),".\nI also highly recommend watching ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=pNhBQJN44YQ",children:"this talk"})," by Daniel Spiewak."]}),"\n",(0,s.jsx)(n.h3,{id:"finger-trees",children:"Finger Trees"}),"\n",(0,s.jsxs)(n.p,{children:["To conclude this section, I would like to share a slightly less popular, but beautifully designed\ndata structure called \u201cfinger tree\u201d described in ",(0,s.jsx)(n.a,{href:"http://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf",children:"this paper"}),"\nby Hinze and Paterson. Enjoy the read and this animation of a finger tree getting filled with some numbers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import de.sciss.fingertree.{FingerTree, Measure}\nimport reftree.contrib.FingerTreeInstances._\n\nimplicit val measure = Measure.Indexed\n\nAnimation\n  .startWith(FingerTree(1))\n  .iterateWithIndex(21)((t, i) => t :+ (i + 1))\n  .build(Diagram(_).withCaption("Finger Tree").withAnchor("tree"))\n  .render("finger", _.withDensity(75).withVerticalSpacing(2))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"finger",src:a(7580).A+"",width:"1730",height:"1160"})}),"\n",(0,s.jsx)(n.h2,{id:"lenses",children:"Lenses"}),"\n",(0,s.jsxs)(n.p,{children:["So far we were looking into \u201cstandard\u201d data structures,\nbut in our code we often have to deal with custom data structures comprising our domain model.\nUpdating this sort of data can be tricky if it\u2019s immutable.\nFor case classes Scala gives us the ",(0,s.jsx)(n.code,{children:"copy"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Employee(\n  name: String,\n  salary: Long\n)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'employee\n// res7: Employee = Employee(name = "Michael", salary = 4000L)\nval raisedEmployee = employee.copy(salary = employee.salary + 10)\n// raisedEmployee: Employee = Employee(name = "Michael", salary = 4010L)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["However once composition comes into play, the resulting nested immutable data structures\nwould require a lot of ",(0,s.jsx)(n.code,{children:"copy"})," calls:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Employee(\n  name: String,\n  salary: Long\n)\n\ncase class Startup(\n  name: String,\n  founder: Employee,\n  team: List[Employee]\n)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'startup\n// res8: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "Michael", salary = 4000L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2100L),\n//     Employee(name = "Bella", salary = 2100L),\n//     Employee(name = "Chad", salary = 1980L),\n//     Employee(name = "Delia", salary = 1850L)\n//   )\n// )\nval raisedFounder = startup.copy(\n  founder = startup.founder.copy(\n    salary = startup.founder.salary + 10\n  )\n)\n// raisedFounder: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "Michael", salary = 4010L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2100L),\n//     Employee(name = "Bella", salary = 2100L),\n//     Employee(name = "Chad", salary = 1980L),\n//     Employee(name = "Delia", salary = 1850L)\n//   )\n// )\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"// extra declarations for this section\nimport reftree.contrib.SimplifiedInstances.{list => listInstance}\nimport reftree.contrib.OpticInstances._\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(startup) + diagram(raisedFounder)).render("startup")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"startup",src:a(7056).A+"",width:"1977",height:"701"})}),"\n",(0,s.jsx)(n.p,{children:"Ouch!"}),"\n",(0,s.jsxs)(n.p,{children:["A common solution to this problem is a \u201clens\u201d.\nIn the simplest case a lens is a pair of functions to get and set a value of type ",(0,s.jsx)(n.code,{children:"B"})," inside a value of type ",(0,s.jsx)(n.code,{children:"A"}),".\nIt\u2019s called a lens because it focuses on some part of the data and allows to update it.\nFor example, here is a lens that focuses on an employee\u2019s salary\n(using the excellent ",(0,s.jsx)(n.a,{href:"https://github.com/julien-truffaut/Monocle",children:"Monocle library"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import monocle.macros.GenLens\n\nval salaryLens = GenLens[Employee](_.salary)\n// salaryLens: monocle.package.Lens[Employee, Long] = repl.MdocSession$MdocApp$$anon$1@5eedf892\n\nsalaryLens.get(startup.founder)\n// res10: Long = 4000L\nsalaryLens.modify(s => s + 10)(startup.founder)\n// res11: Employee = Employee(name = "Michael", salary = 4010L)\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(OpticFocus(salaryLens, startup.founder)).render("salaryLens")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"salaryLens",src:a(7817).A+"",width:"592",height:"363"})}),"\n",(0,s.jsx)(n.p,{children:"We can also define a lens that focuses on the startup\u2019s founder:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val founderLens = GenLens[Startup](_.founder)\n// founderLens: monocle.package.Lens[Startup, Employee] = repl.MdocSession$MdocApp$$anon$2@56f23749\n\nfounderLens.get(startup)\n// res13: Employee = Employee(name = "Michael", salary = 4000L)\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(OpticFocus(founderLens, startup)).render("founderLens")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"founderLens",src:a(1738).A+"",width:"1832",height:"701"})}),"\n",(0,s.jsx)(n.p,{children:"It\u2019s not apparent yet how this would help, but the trick is that lenses can be composed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val founderSalaryLens = founderLens composeLens salaryLens\n// founderSalaryLens: monocle.PLens[Startup, Startup, Long, Long] = monocle.PLens$$anon$1@3b84f3b2\n\nfounderSalaryLens.get(startup)\n// res15: Long = 4000L\nfounderSalaryLens.modify(s => s + 10)(startup)\n// res16: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "Michael", salary = 4010L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2100L),\n//     Employee(name = "Bella", salary = 2100L),\n//     Employee(name = "Chad", salary = 1980L),\n//     Employee(name = "Delia", salary = 1850L)\n//   )\n// )\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(OpticFocus(founderSalaryLens, startup)).render("founderSalaryLens")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"founderSalaryLens",src:a(5288).A+"",width:"1866",height:"701"})}),"\n",(0,s.jsx)(n.p,{children:"One interesting thing is that lenses can focus on anything, not just direct attributes of the data.\nHere is a traversal \u2014 a more generic kind of lens \u2014 that focuses on all vowels in a string:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(OpticFocus(vowelTraversal, "example")).render("vowelTraversal")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"vowelTraversal",src:a(2964).A+"",width:"494",height:"193"})}),"\n",(0,s.jsx)(n.p,{children:"We can use it to give our founder a funny name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val employeeNameLens = GenLens[Employee](_.name)\n// employeeNameLens: monocle.package.Lens[Employee, String] = repl.MdocSession$MdocApp$$anon$3@47f92c7a\nval founderVowelTraversal = founderLens composeLens employeeNameLens composeTraversal vowelTraversal\n// founderVowelTraversal: monocle.PTraversal[Startup, Startup, Char, Char] = monocle.PTraversal$$anon$2@73f506c1\n\nfounderVowelTraversal.modify(v => v.toUpper)(startup)\n// res19: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "MIchAEl", salary = 4000L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2100L),\n//     Employee(name = "Bella", salary = 2100L),\n//     Employee(name = "Chad", salary = 1980L),\n//     Employee(name = "Delia", salary = 1850L)\n//   )\n// )\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(OpticFocus(founderVowelTraversal, startup)).render("founderVowelTraversal")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"founderVowelTraversal",src:a(7289).A+"",width:"1889",height:"701"})}),"\n",(0,s.jsxs)(n.p,{children:["So far we have replaced the ",(0,s.jsx)(n.code,{children:"copy"})," boilerplate with a number of lens declarations.\nHowever most of the time our goal is just to update data."]}),"\n",(0,s.jsxs)(n.p,{children:["In Scala there is a great library called ",(0,s.jsx)(n.a,{href:"https://github.com/adamw/quicklens",children:"quicklens"}),"\nthat allows to do exactly that, creating all the necessary lenses under the hood:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import com.softwaremill.quicklens._\n\nval raisedCeo = startup.modify(_.founder.salary).using(s => s + 10)\n// raisedCeo: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "Michael", salary = 4010L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2100L),\n//     Employee(name = "Bella", salary = 2100L),\n//     Employee(name = "Chad", salary = 1980L),\n//     Employee(name = "Delia", salary = 1850L)\n//   )\n// )\n'})}),"\n",(0,s.jsx)(n.p,{children:"You might think this is approaching the syntax for updating mutable data,\nbut actually we have already surpassed it, since lenses are much more flexible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val raisedEveryone = startup.modifyAll(_.founder.salary, _.team.each.salary).using(s => s + 10)\n// raisedEveryone: Startup = Startup(\n//   name = "Acme",\n//   founder = Employee(name = "Michael", salary = 4010L),\n//   team = List(\n//     Employee(name = "Adam", salary = 2110L),\n//     Employee(name = "Bella", salary = 2110L),\n//     Employee(name = "Chad", salary = 1990L),\n//     Employee(name = "Delia", salary = 1860L)\n//   )\n// )\n'})}),"\n",(0,s.jsx)(n.h2,{id:"zippers",children:"Zippers"}),"\n",(0,s.jsx)(n.p,{children:"In our domain models we are often faced with recursive data structures.\nConsider this example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Employee(\n  name: String,\n  salary: Long\n)\n\ncase class Hierarchy(\n  employee: Employee,\n  team: List[Hierarchy]\n)\n\ncase class Company(\n  name: String,\n  hierarchy: Hierarchy\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Hierarchy"})," class refers to itself.\nLet\u2019s grab a company object and display its hierarchy as a tree:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"// extra declarations for this section\nimport zipper._\nimport reftree.contrib.SimplifiedInstances.option\nimport reftree.contrib.ZipperInstances._\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(company.hierarchy).render("company")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"company",src:a(3422).A+"",width:"2283",height:"1210"})}),"\n",(0,s.jsxs)(n.p,{children:["What if we want to navigate through this tree and modify it along the way?\nWe can use ",(0,s.jsx)(n.a,{href:"#lenses",children:"lenses"}),", but the recursive nature of the tree allows for a better solution."]}),"\n",(0,s.jsxs)(n.p,{children:["This solution is called a \u201cZipper\u201d, and was introduced by G\xe9rard Huet in 1997.\nIt consists of a \u201ccursor\u201d pointing to a location anywhere in the tree \u2014 \u201ccurrent focus\u201d.\nThe cursor can be moved freely with operations like ",(0,s.jsx)(n.code,{children:"moveDownLeft"}),", ",(0,s.jsx)(n.code,{children:"moveRight"}),", ",(0,s.jsx)(n.code,{children:"moveUp"}),", etc.\nCurrent focus can be updated, deleted, or new nodes can be inserted to its left or right.\nZippers are immutable, and every operation returns a new Zipper.\nAll the changes made to the tree can be committed, yielding a new modified version of the original tree."]}),"\n",(0,s.jsx)(n.p,{children:"Here is how we would insert a new employee into the hierarchy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val updatedHierarchy = Zipper(company.hierarchy).moveDownRight.moveDownRight.insertRight(newHire).commit\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(company.hierarchy) + diagram(updatedHierarchy)).render("updatedHierarchy")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"updatedHierarchy",src:a(365).A+"",width:"2505",height:"1210"})}),"\n",(0,s.jsxs)(n.p,{children:["My ",(0,s.jsx)(n.a,{href:"https://github.com/stanch/zipper#zipper--an-implementation-of-huets-zipper",children:"zipper library"}),"\nprovides a few useful movements and operations."]}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s consider a simpler recursive data structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Tree(x: Int, c: List[Tree] = List.empty)\n"})}),"\n",(0,s.jsx)(n.p,{children:"and a simple tree:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"simpleTree\n// res23: Tree = Tree(\n//   x = 1,\n//   c = List(\n//     Tree(x = 2, c = List()),\n//     Tree(x = 3, c = List()),\n//     Tree(x = 4, c = List()),\n//     Tree(x = 5, c = List(Tree(x = 6, c = List()), Tree(x = 7, c = List())))\n//   )\n// )\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(simpleTree).render("simpleTree")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"simpleTree",src:a(977).A+"",width:"925",height:"721"})}),"\n",(0,s.jsx)(n.p,{children:"When we wrap a Zipper around this tree, it does not look very interesting yet:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper1 = Zipper(simpleTree)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(simpleTree) + diagram(zipper1)).render("zipper1")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper1",src:a(3596).A+"",width:"998",height:"890"})}),"\n",(0,s.jsx)(n.p,{children:"We can see that it just points to the original tree and has some other empty fields.\nMore specifically, a Zipper consists of four pointers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Zipper[A](\n  left: List[A],           // left siblings of the focus\n  focus: A,                // the current focus\n  right: List[A],          // right siblings of the focus\n  top: Option[Zipper[A]]   // the parent zipper\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case the focus is the root of the tree, which has no siblings,\nand the parent zipper does not exist, since we are at the top level."}),"\n",(0,s.jsx)(n.p,{children:"One thing we can do right away is modify the focus:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper2 = zipper1.update(focus => focus.copy(x = focus.x + 99))\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(simpleTree) + diagram(zipper1) + diagram(zipper2)).render("zipper2")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper2",src:a(7879).A+"",width:"1299",height:"890"})}),"\n",(0,s.jsx)(n.p,{children:"We just created a new tree! To obtain it, we have to commit the changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val tree2 = zipper2.commit\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(simpleTree) + diagram(tree2)).render("tree2")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"tree2",src:a(4025).A+"",width:"947",height:"721"})}),"\n",(0,s.jsx)(n.p,{children:"If you were following closely,\nyou would notice that nothing spectacular happened yet:\nwe could\u2019ve easily obtained the same result by modifying the tree directly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val tree2b = simpleTree.copy(x = simpleTree.x + 99)\n\nassert(tree2b == tree2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The power of Zipper becomes apparent when we go one or more levels deep.\nTo move down the tree, we \u201cunzip\u201d it, separating the child nodes into\nthe focused node and its left and right siblings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper3 = zipper1.moveDownLeft\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'(diagram(zipper1) + diagram(zipper3)).render("zipper1+3")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper1+3",src:a(3146).A+"",width:"973",height:"1060"})}),"\n",(0,s.jsx)(n.p,{children:"The new Zipper links to the old one,\nwhich will allow us to return to the root of the tree when we are done applying changes.\nThis link however prevents us from seeing the picture clearly.\nLet\u2019s look at the second zipper alone:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(zipper3).render("zipper3")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper3",src:a(4862).A+"",width:"927",height:"758"})}),"\n",(0,s.jsxs)(n.p,{children:["Great! We have ",(0,s.jsx)(n.code,{children:"2"})," in focus and ",(0,s.jsx)(n.code,{children:"3, 4, 5"})," as right siblings. What happens if we move right a bit?"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper4 = zipper3.moveRightBy(2)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(zipper4).render("zipper4")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper4",src:a(3358).A+"",width:"818",height:"758"})}),"\n",(0,s.jsx)(n.p,{children:"This is interesting! Notice that the left siblings are \u201cinverted\u201d.\nThis allows to move left and right in constant time, because the sibling\nadjacent to the focus is always at the head of the list."}),"\n",(0,s.jsx)(n.p,{children:"This also allows us to insert new siblings easily:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper5 = zipper4.insertLeft(Tree(34))\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(zipper5).render("zipper5")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper5",src:a(2712).A+"",width:"935",height:"758"})}),"\n",(0,s.jsx)(n.p,{children:"And, as you might know, we can delete nodes and update the focus:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper6 = zipper5.deleteAndMoveRight.set(Tree(45))\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(zipper6).render("zipper6")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper6",src:a(7203).A+"",width:"531",height:"494"})}),"\n",(0,s.jsx)(n.p,{children:"Finally, when we move up, the siblings at the current level are \u201czipped\u201d\ntogether and their parent node is updated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zipper7 = zipper6.moveUp\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'diagram(zipper7).render("zipper7")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"zipper7",src:a(1994).A+"",width:"777",height:"626"})}),"\n",(0,s.jsxs)(n.p,{children:["You can probably guess by now that ",(0,s.jsx)(n.code,{children:".commit"})," is a shorthand for going\nall the way up (applying all the changes) and returning the focus:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val tree3a = zipper6.moveUp.focus\nval tree3b = zipper6.commit\n\nassert(tree3a == tree3b)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here is an animation of the navigation process:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val movement = Animation\n  .startWith(Zipper(Data.simpleTree))\n  .iterate(\n    _.moveDownLeft,\n    _.moveRight, _.moveRight, _.moveRight,\n    _.moveDownLeft,\n    _.moveRight, _.moveLeft,\n    _.top.get,\n    _.moveLeft, _.moveLeft, _.moveLeft,\n    _.top.get\n  )\n\nval trees = movement\n  .build(z => Diagram(ZipperFocus(z, Data.simpleTree)).withCaption("Tree").withAnchor("tree"))\n  .toNamespace("tree")\n\nval zippers = movement\n  .build(Diagram(_).withCaption("Zipper").withAnchor("zipper").withColor(2))\n  .toNamespace("zipper")\n\n(trees + zippers).render("tree+zipper")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"tree+zipper",src:a(1864).A+"",width:"1241",height:"690"})}),"\n",(0,s.jsx)(n.h2,{id:"useful-resources",children:"Useful resources"}),"\n",(0,s.jsx)(n.h3,{id:"books-papers-and-talks",children:"Books, papers and talks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504",children:"Purely functional data structures"})," by Chris Okasaki,\nand/or ",(0,s.jsx)(n.a,{href:"https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf",children:"his PhD thesis"})," \u2014 ",(0,s.jsx)(n.em,{children:"the"})," introduction to immutable data structures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://cstheory.stackexchange.com/a/1550",children:"What\u2019s new in purely functional data structures since Okasaki"})," \u2014 an excellent StackExchange answer\nwith pointers for further reading"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=pNhBQJN44YQ",children:"Extreme cleverness"})," by Daniel Spiewak \u2014 a superb talk\ncovering several immutable data structures (implemented ",(0,s.jsx)(n.a,{href:"https://github.com/djspiewak/extreme-cleverness",children:"here"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://hypirion.com/musings/understanding-persistent-vector-pt-1",children:"Understanding Clojure\u2019s Persistent Vectors, part 1"}),"\nand ",(0,s.jsx)(n.a,{href:"http://hypirion.com/musings/understanding-persistent-vector-pt-2",children:"part 2"})," \u2014 a series of blog posts by Jean Niklas L\u2019orange"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf",children:"Finger Trees"})," and\n",(0,s.jsx)(n.a,{href:"http://www.cs.ox.ac.uk/ralf.hinze/publications/Brother12.pdf",children:"1-2 Brother Trees"})," described by Hinze and Paterson"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf",children:"Huet\u2019s original Zipper paper"})," \u2014 a great short read\nintroducing the Zipper"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://dspace.library.uu.nl/bitstream/handle/1874/2532/2001-33.pdf",children:"Weaving a web"})," by Hinze and Jeuring \u2014\nanother interesting Zipper-like approach"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scala-libraries",children:"Scala libraries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/stanch/zipper",children:"zipper"})," \u2014 my Zipper implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/julien-truffaut/Monocle",children:"Monocle"})," \u2014 an \u201coptics\u201d library"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/adamw/quicklens",children:"Quicklens"})," \u2014 a simpler way to update nested case classes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/Sciss/FingerTree",children:"FingerTree"})," \u2014 an implementation of the Finger Tree data structure"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},7580:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/finger-b0999bed13c76359869b636227548cc6.gif"},5390:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/big-vectors-4b0f5120bf4a32b8802dc41e520eb37a.png"},3422:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/company-3188e3cf359d9f1c7224ffceed126083.png"},1738:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/founderLens-005975324dcee19c77494d453f8647c2.png"},5288:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/founderSalaryLens-89e3e6d28efff27c4c8f563cfa49d3ee.png"},7289:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/founderVowelTraversal-d35014cf80294acb4990d554bcedb0d3.png"},2773:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/list-append-063e66f9ba76613ce2a8ba351ea27ee8.gif"},2515:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/list-prepend-d90a987fd8bfc72246aa9c61dbfcf1c8.gif"},8603:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/list-a190da16976869e8e07bee62d501a9f7.png"},2600:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/lists-58f15f89774ee685a16243b40e9ba7c2.png"},5623:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/queues-5efd3f3abf9c377155a0b4b6de6a77f9.png"},7817:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/salaryLens-0d89d07dc97f512aa7fe6b50f061cfcd.png"},977:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/simpleTree-bbaebacbd585b97eea7d64d94848caf8.png"},7056:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/startup-2a750a1231daf1c2d9c548867f54ffc1.png"},4025:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/tree2-9e8f1e7e745ac62ee27f909cf0770ae0.png"},365:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/updatedHierarchy-ca0b5d651e31d5815f0d14c96fd928ad.png"},1999:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/vectors-d5f0252feb82955ab0584957427fb307.png"},2964:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/vowelTraversal-6534f12953b90dc5b6d40f6ee44e6c27.png"},3146:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper1+3-dafaaae54d3abc9716c59963ceb6f171.png"},3596:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper1-4a80c9c87d37df30e02c064945cde2f6.png"},7879:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper2-1176392f67e450e82bfa63dabbeacf90.png"},4862:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper3-9ab483dc84adf5005cafecc77e51e394.png"},3358:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper4-283827a5d36341e55ced1d024b328633.png"},2712:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper5-ce83ff83213a95c042b81012c81a28fc.png"},7203:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper6-4431d6974f1d299e656fa1e5c8d54fb0.png"},1994:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/zipper7-cd17a63fb6f4732884da00b544ffa549.png"},9696:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/queue-668a708310e8e78475fbc9b757c69eb3.gif"},1864:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/tree+zipper-b1cf73da287eda26f64b667ce8dcf311.gif"}}]);